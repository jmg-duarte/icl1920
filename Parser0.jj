PARSER_BEGIN(Parser)

package parser;

import java.util.Map;
import java.util.HashMap;

import ast.*;
import compiler.*;
import env.*;

/** ID lister. */
public class Parser{}
PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN :
{
    < LET: "let" >
  | < IN: "in" >
  | < END: "end" >
  | < NEW: "new" >
  | < IF: "if" >
  | < THEN: "then" >
  | < ELSE: "else">
  | < WHILE: "while" >
  | < DO: "do" >
  | < NOT: "~">
  | < AND: "&&" >
  | < OR: "||">
  | < COMMA: "," >
  | < Num: (["0"-"9"]) + >
  | < PLUS : "+" >
  | < MINUS : "-">
  | < EQ : "==" >
  | < DF : "!=" >
  | < GT: ">" >
  | < GE: ">=" >
  | < LT : "<" >
  | < LE : "<=" >
  | < TIMES : "*">
  | < DIV : "/">
  | < LPAR : "(" >
  | < RPAR : ")" >
  | < EL: ";;" >
  | < SEQ:  ";" >
  | < EQUALS: "=" >
  | < DEREF: "!" >
  | < ASSIGN: ":=" >
  | < BOOL: ("true" | "false") >
  | < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >

}

ASTNode Start(): { 
  ASTNode t; 
} {
   t = BooleanOr() <EL>
   { return t; }
}

ASTNode BooleanOr() :
{ ASTNode exp1, exp2;}
{
    exp1=BooleanAnd() (
        <OR> exp2=BooleanAnd()
            { exp1 = new ASTBooleanOp("||", exp1, exp2); }
        ) *
        {return exp1;}
}

ASTNode BooleanAnd() :
{ ASTNode exp1, exp2; }
{
    exp1=Comparation() (
        <AND> exp2=Comparation()
            { exp1 = new ASTBooleanOp("&&", exp1, exp2); }
        ) *
        {return exp1;}
}

ASTNode Comparation() :
{ Token op; ASTNode exp1, exp2;
}
{
    exp1=Exp() (
            (op = <EQ> | op=<LT> | op=<GT> | op=<GE> | op=<LE> | op=<DF>) exp2=Exp()
                { exp1 = new ASTComparationOp(op.image, exp1, exp2); }
            ) *
            {return exp1;}
}

ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
    t1=Term() (
    ( op=<PLUS> | op=<MINUS> ) t2=Term()
        { t1 = new ASTBinaryOp(op.image, t1, t2); }
    ) *
    {return t1;}
}

ASTNode Term() :
{ Token op;
  ASTNode t1, t2; }
{
    t1=UnaryExp() (
        ( op=<TIMES> | op=<DIV> ) t2=UnaryExp() {
            t1 = new ASTBinaryOp(op.image, t1, t2);
            }
        ) *
    { return t1; }
}


ASTNode UnaryExp() :
{  Token op;
   ASTNode t1; }
{
    ( (op = <MINUS> | op = <PLUS>) t1 = UnaryExp()
        { t1 = new ASTUnaryOp(op.image, t1); }
    | t1 = Fact()
    )
    { return t1; }
}

ASTNode Fact() :  {
    Token n;
    ASTNode t;}
{
   ( n=<Num> {t = new ASTNum(Integer.parseInt(n.image));}
   | t = Bool()
   | <NEW> t = Fact() { t = new ASTNew(t); }
   | t = Id()
   | t = Let()
   //| t = If()
   //| t = While()
   | <LPAR> t=Exp() <RPAR>
   )
   { return t; }
}


ASTNode Id() : {
    Token id;
} {
    id = <Id> { return new ASTId(id.image); }
}

ASTNode Bool() : {
    Token bool;
} {
    bool = <BOOL> {
        switch(bool.image) {
            case "true": return ASTBool.True();
            case "false": return ASTBool.False();
        }
    }
}

/*
ASTNode If() : {
    ASTNode exp1;
    ASTNode exp2;
    ASTNode exp3;
   } {
        <IF> exp1 = Exp() <THEN> exp2 = Exp() <ELSE> exp3 = Exp() <END>
    return new ASTIf(exp1, exp2, exp3);
}

ASTNode While() : {
    ASTNode exp1;
    ASTNode exp2;
    {
    <WHILE> exp1 = Exp() <DO> exp2 = Exp() <END>
    }
    return new ASTWhile(exp1, exp2);
}
*/
ASTNode Let() : {
    Token id;
    ASTNode expression;
    ASTNode body;
    Map<String, ASTNode> expressions = new HashMap<String, ASTNode>();
} {
    <LET> id=<Id> <EQUALS> expression=Exp()
        {expressions.put(id.image,expression);}
        (<COMMA> id=<Id> <EQUALS> expression=Exp()
        {
            if (expressions.put(id.image,expression) != null) {
                throw new RuntimeException("duplicate assignment");
            }
        } )*
         <IN> body=Exp() <END>
    {
        return new ASTLetIn(expressions, body);
    }
}
