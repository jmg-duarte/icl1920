PARSER_BEGIN(Parser)

package parser;

import java.util.Map;
import java.util.HashMap;

import ast.*;
import compiler.*;
import env.*;

/** ID lister. */
public class Parser{}
PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN :
{
    < LET: "let" >
  | < IN: "in" >
  | < END: "end" >
  | < NEW: "new" >
  | < IF: "if" >
  | < THEN: "then" >
  | < ELSE: "else">
  | < WHILE: "while" >
  | < DO: "do" >
  | < BOOL: ("true" | "false") >
  | < NOT: "~">
  | < AND: "&&" >
  | < OR: "||">
  | < COMMA: "," >
  | < Num: (["0"-"9"]) + >
  | < PLUS : "+" >
  | < MINUS : "-">
  | < EQ : "==" >
  | < DF : "!=" >
  | < GT: ">" >
  | < GE: ">=" >
  | < LT : "<" >
  | < LE : "<=" >
  | < TIMES : "*">
  | < DIV : "/">
  | < LPAR : "(" >
  | < RPAR : ")" >
  | < EL: ";;" >
  | < SEQ:  ";" >
  | < EQUALS: "=" >
  | < DEREF: "!" >
  | < ASSIGN: ":=" >
  | < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >

}

ASTNode Start(): { 
  ASTNode t; 
} {
   t = Expression() <EL>
   { return t; }
}

ASTNode Expression() : {
    ASTNode head, tail;
} {
    head = Assign() (
        <SEQ> tail = Assign()
            {head = new ASTSequence(head, tail);}
        )*
    { return head; }
}

ASTNode Assign() : {
    ASTNode left, right;
} {
    left = BooleanOr() (
        <ASSIGN> right = BooleanOr()
            {left = new ASTAssign(left, right);}
        )*
    { return left; }
}

ASTNode BooleanOr() :
{ ASTNode exp1, exp2;}
{
    exp1=BooleanAnd() (
        <OR> exp2=BooleanAnd()
            { exp1 = new ASTBooleanOp("||", exp1, exp2); }
        ) *
        {return exp1;}
}

ASTNode BooleanAnd() :
{ ASTNode exp1, exp2; }
{
    exp1=Equals() (
        <AND> exp2=Equals()
            { exp1 = new ASTBooleanOp("&&", exp1, exp2); }
        ) *
        {return exp1;}
}

ASTNode Equals() : {
    Token op;
    ASTNode left, right;
} {
    left=Comparison() (
        (op = <EQ> | op = <DF>) right = Comparison()
        {left = new ASTEquality(op.image, left, right);}
    ) *
    {return left;}
}

ASTNode Comparison() :
{ Token op; ASTNode exp1, exp2;
} {
    exp1=Exp() (
        (op=<LT> | op=<GT> | op=<GE> | op=<LE>) exp2=Exp()
        { exp1 = new ASTComparisonOp(op.image, exp1, exp2); }
    ) *
    {return exp1;}
}

ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
    t1=Term() (
    ( op=<PLUS> | op=<MINUS> ) t2=Term()
        { t1 = new ASTBinaryOp(op.image, t1, t2); }
    ) *
    {return t1;}
}

ASTNode Term() :
{ Token op;
  ASTNode t1, t2; }
{
    t1=UnaryExp() (
        ( op=<TIMES> | op=<DIV> ) t2=UnaryExp() {
            t1 = new ASTBinaryOp(op.image, t1, t2);
            }
        ) *
    { return t1; }
}


ASTNode UnaryExp() :
{  Token op;
   ASTNode t1; }
{
    ( (op = <MINUS> | op = <PLUS>) t1 = UnaryExp()
        { t1 = new ASTUnaryOp(op.image, t1); }
    | t1 = Fact()
    )
    { return t1; }
}

ASTNode Fact() :  {
    Token n;
    ASTNode t;
} {
   ( n=<Num> {t = new ASTNum(Integer.parseInt(n.image));}
   | <NEW> t = Fact() { t = new ASTNew(t); }
   | <NOT> t = Fact() { t = new ASTNot(t); }
   | <DEREF> t = Fact() { t = new ASTDeref(t); }
   | t = Bool()
   | t = Let()
   | t = If()
   | t = While()
   | t = Id()
   | <LPAR> t = Expression() <RPAR>
   )
   { return t; }
}


ASTNode Id() : {
    Token id;
} {
    id = <Id> { return new ASTId(id.image); }
}

ASTNode Bool() : {
    Token bool;
} {
    bool = <BOOL> {
        switch(bool.image) {
            case "true": return ASTBool.True();
            case "false": return ASTBool.False();
        }
    }
}

ASTNode If() : {
    ASTNode exp1;
    ASTNode exp2;
    ASTNode exp3;
   } {
        <IF> exp1 = Expression() <THEN> exp2 = Expression() <ELSE> exp3 = Expression() <END>
        {return new ASTIf(exp1, exp2, exp3);}
}


ASTNode While() : {
    ASTNode exp1;
    ASTNode exp2;
    } {
    <WHILE> exp1 = Expression() <DO> exp2 = Expression() <END>
    {return new ASTWhile(exp1, exp2);}
}


ASTNode Let() : {
    Token id;
    ASTNode expression;
    ASTNode body;
    Map<String, ASTNode> expressions = new HashMap<String, ASTNode>();
} {
    <LET> id=<Id> <EQUALS> expression=Expression()
        {expressions.put(id.image,expression);}
        (<COMMA> id=<Id> <EQUALS> expression=Expression()
        {
            if (expressions.put(id.image,expression) != null) {
                throw new RuntimeException("duplicate assignment");
            }
        } )*
         <IN> body=Expression() <END>
    {
        return new ASTLetIn(expressions, body);
    }
}
